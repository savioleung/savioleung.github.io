---
layout: post
title: goalf
categories: [c++, game]
tags: []
description: ! 物理で動くボールを弾いてゴールに入れるゲーム
---
![goalf1](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf_1.png)

タイトル：goalf

コンセプト：物理で動くボールを弾いてゴールに入れるゲーム

Github:[goalf](https://github.com/savioleung/goalf)


説明↓

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf_2.png)

![goalf3](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf_3.png)

これはは画面を引っ張って、マウス左クリックの押した位置と離した位置に応じた、角度を計算して、ジャンプするボールを赤いかごに入れるゲーム

ボールは壁に当たったらもう一回だけジャンプすることが出来る、壁ジャンプです

足場に触れたら、ジャンプ回数は回復します。

{% highlight cpp %}
//遊べる時
			if (play) {
				//編集BGMを止めて、ゲームBGMを再生
				if (audioList[1].isPlaying()) {
					audioList[1].stop();
				}
				audioList[2].play();
#pragma region 引っ張って飛ぶ

				if (MouseL.down() && !clicking)
				{
					aiming = true;
					enterPos = Cursor::Pos();
					clicking = true;
				}
				if (MouseL.up() && clicking)
				{
					aiming = false;
					//地面判定
					//発射時ボールが接触しているオブジェクト
					for (auto [pair, collision] : world.getCollisions())
					{
						//世界中の当たり判定の中でボールがある当たり判定
						if (pair.a == myBallID || pair.b == myBallID)
						{
							//壁に当たった場合、もう一回ジャンプできる
							if (wallCollidedIDs.includes(pair.a) || wallCollidedIDs.includes(pair.b)) {
								canJump = true;
							}//地面に当たった場合、ジャンプ回数リセット
							else if (floorCollidedIDs.includes(pair.a) || floorCollidedIDs.includes(pair.b))
							{
								canJump = true;
								ballJump = 2;
							}

						}
					}
					outPos = Cursor::Pos();

					Vec2 ang;
					//同じく地点を引っ張って、弾く方向計算できない場合、角度を計算
					if (outPos != enterPos) {
						ang = (enterPos - outPos).normalized();
					}
					else
					{
						ang = Vec2(0, 0);
					}
					double dis = twoPointDistance(enterPos, outPos);

					//最小と最大の力を制限
					if (dis < 5) { dis = 5; }
					if (dis > 40) { dis = 40; }

					if (stopTime && ang == Vec2(0, 0)) {

						myBall.setVelocity(savePos);
						stopTime = false;
					}
					//ジャンプ
					if (canJump) {
						if (ballJump > 0) {
							audioList[0].play();
							myBall.setVelocity(Vec2(0, 0));
							myBall.applyLinearImpulse(ang * dis * 35);
							ballJump--;
							jumpNum++;
							canJump = false;
						}
					}
					clicking = false;
				}

#pragma endregion


				//右クリックで遅くなる
				if (MouseR.pressed()) {
					myBall.setVelocity(myBall.getVelocity() * 0.98);

				}
				//常に判定取得処理
				for (auto [pair, collision] : world.getCollisions())
				{
					if (pair.a == myBallID || pair.b == myBallID)
					{
						//ゴールの底ついたらゴール判定
						if (pair.a == Goal[2].id() || pair.b == Goal[2].id()) {
							aiming = false;
							//ゴールの音声再生
							audioList[3].play();
						}
						else
						{
							audioList[3].stop();
							ClearPrint();
						}
						//壁タッチでもう一回だけジャンプ可能
						if (wallCollidedIDs.includes(pair.a) || wallCollidedIDs.includes(pair.b)) {
							canJump = true;
						}
					}
				}
			}
{% endhighlight %}


ゲームのステージはプレイヤー自身が自由に作れます
{% highlight cpp %}
//足場設置
			if (!play) {
				if (audioList[2].isPlaying()) {
					audioList[2].stop();
				}
				audioList[1].play();
#pragma region ステージ作り


				if (MouseL.pressed())
				{
					//ゲーム画面内のみ設置
					Vec2 PrintPos = Cursor::Pos() - DefaultPos;
					if (PrintPos.x < 39 && PrintPos.x>1 && PrintPos.y < -1 && PrintPos.y>-59) {

						switch (inputMode)
						{
						case 0://足場を設置
							//設置する足場の仮表示
							testingLine.setPos(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y);
							//右クイックで設置
							if (MouseR.down()) {
								floors << setFloor(Vec2(PrintPos.x, -PrintPos.y), size, rot);
								testingLine.setPos(DefaultPos.x + 50, DefaultPos.y - 20);
							}
							break;
						case 1:
							//ゴールの設置
							for (auto& g : Goal)
							{
								g.setPos(Vec2(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y));
							}
							break;
						case 3:
							//足場を画面外に移動（削除）
							for (auto& f : floors)
							{
								Vec2 floorV2 = f.getPos() - DefaultPos;
								double dis = twoPointDistance(floorV2, PrintPos);
								//マウスと足場の中心が距離１以下で削除
								if (dis <= 1) {
									f.setPos(Vec2(0, 0));
								}
							}
							break;
						case 4:
							//ボールのスタートポジション
							spwanPos = Vec2(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y);
							break;
						default:
							break;
						}

					}
				}
{% endhighlight %}