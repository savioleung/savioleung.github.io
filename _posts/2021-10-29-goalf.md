---
layout: post
title: [C++, Siv3D]goalf
categories: [C++, Siv3D]
tags: []
description: ! 物理で動くボールを弾いてゴールに入れるゲーム
---
![goalf1](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_1.png)


タイトル：goalf

制作期間:2020/9~2021/1、約30時間

コンセプト：物理で動くボールを弾いてゴールに入れるゲーム

Github:[goalf](https://github.com/savioleung/goalf)

動画：

説明↓

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_2.png)

![goalf3](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_3.png)

これはは画面を引っ張って、マウス左クリックの押した位置と離した位置に応じた、角度を計算して、ジャンプするボールを赤いかごに入れるゲーム

ボールは壁に当たったらもう一回だけジャンプすることが出来る、壁ジャンプです

足場に触れたら、ジャンプ回数は回復します。

ジャンプ中右クリックで速度落とす事ができます、ゴールしやすくために。

{% highlight cpp %}
//遊べる時
if (play) {
//編集BGMを止めて、ゲームBGMを再生
    if (audioList[1].isPlaying()) {
    audioList[1].stop();
}
	audioList[2].play();
#pragma region 引っ張って飛ぶ

if (MouseL.down() && !clicking)
{
aiming = true;
enterPos = Cursor::Pos();
clicking = true;
}
if (MouseL.up() && clicking)
{
	aiming = false;
	//地面判定
	//発射時ボールが接触しているオブジェクト
	for (auto [pair, collision] : world.getCollisions())
	{
	//世界中の当たり判定の中でボールがある当たり判定
		if (pair.a == myBallID || pair.b == myBallID)
		{
            //壁に当たった場合、もう一回ジャンプできる
            if (wallCollidedIDs.includes(pair.a) || wallCollidedIDs.includes(pair.b)) {
			canJump = true;
		}//地面に当たった場合、ジャンプ回数リセット
		else if (floorCollidedIDs.includes(pair.a) || floorCollidedIDs.includes(pair.b))
		{
			canJump = true;
			ballJump = 2;
		}
        }
}
	outPos = Cursor::Pos();
					Vec2 ang;
	//同じく地点を引っ張って、弾く方向計算できない場合、角度を計算
	if (outPos != enterPos) {
		ang = (enterPos - outPos).normalized();
	}
	else
	{
		ang = Vec2(0, 0);
	}
	double dis = twoPointDistance(enterPos, outPos);
	//最小と最大の力を制限
	if (dis < 5) { dis = 5; }
	if (dis > 40) { dis = 40; }

	if (stopTime && ang == Vec2(0, 0)) {

		myBall.setVelocity(savePos);
		stopTime = false;
	}
	//ジャンプ
	if (canJump) {
		if (ballJump > 0) {
			audioList[0].play();
			myBall.setVelocity(Vec2(0, 0));
			myBall.applyLinearImpulse(ang * dis * 35);
			ballJump--;
			jumpNum++;
			canJump = false;
		}
	}
	clicking = false;
}

#pragma endregion


//右クリックで遅くなる
if (MouseR.pressed()) {
	myBall.setVelocity(myBall.getVelocity() * 0.98);
}
//常に判定取得処理
for (auto [pair, collision] : world.getCollisions())
{
	if (pair.a == myBallID || pair.b == myBallID)
	{
		//ゴールの底ついたらゴール判定
		if (pair.a == Goal[2].id() || pair.b == Goal[2].id()) {
			aiming = false;
			//ゴールの音声再生
			audioList[3].play();
		}
		else
		{
			audioList[3].stop();
			ClearPrint();
		}
		//壁タッチでもう一回だけジャンプ可能
		if (wallCollidedIDs.includes(pair.a) || wallCollidedIDs.includes(pair.b)) {
			canJump = true;
		}
	}
}
{% endhighlight %}


ゲームのステージはプレイヤー自身が自由に作れます

右のエディターメニューで、プレイ状態じゃない場合、ステージ作りができます。

上から

1. 足場の設置、角度、長さも変換出来ます　ゲーム枠にマウス左ボタン押しっぱなしで足場の仮表示、そのまま右クリックで足場の設置が確定します。

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_4.png)

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_5.png)

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_6.png)


2. ゴールの設置、枠内に自由に設置ができます

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_8.png)

3. マウスの軌跡で線を描いて、をのまま足場に出来ます、形を描けば、中身を埋めます。

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_9.png)

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_10.png)

4. 足場の削除、マウス左ボタン押しっぱなしで足場の中心位置に近づけば足場の削除ができます

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_11.png)

5.プレイヤーの開始地点を設置

![goalf2](https://raw.githubusercontent.com/savioleung/savioleung.github.io/master/images/goalf/goalf_12.png)

3番の線を引く足場以外は↓のプログラムでまとめています

{% highlight cpp %}
//足場設置
if (!play) {
    if (audioList[2].isPlaying()) {
	audioList[2].stop();
}
audioList[1].play();
#pragma region ステージ作り
if (MouseL.pressed())
{
	//ゲーム画面内のみ設置
	Vec2 PrintPos = Cursor::Pos() - DefaultPos;
	if (PrintPos.x < 39 && PrintPos.x>1 && PrintPos.y < -1 && PrintPos.y>-59) {
		switch (inputMode)
        {
            case 0://足場を設置
			//設置する足場の仮表示
			testingLine.setPos(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y);
			//右クイックで設置
			if (MouseR.down()) {
				floors << setFloor(Vec2(PrintPos.x, -PrintPos.y), size, rot);
				testingLine.setPos(DefaultPos.x + 50, DefaultPos.y - 20);
			}
			break;
		case 1:
			//ゴールの設置
			for (auto& g : Goal)
			{
				g.setPos(Vec2(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y));
			}
			break;
		case 3:
			//足場を画面外に移動（削除）
			for (auto& f : floors)
			{
				Vec2 floorV2 = f.getPos() - DefaultPos;
				double dis = twoPointDistance(floorV2, PrintPos);
				//マウスと足場の中心が距離１以下で削除
				if (dis <= 1) {
					f.setPos(Vec2(0, 0));
				}
			}
			break;
		case 4:
			//ボールのスタートポジション
			spwanPos = Vec2(DefaultPos.x + PrintPos.x, DefaultPos.y - -PrintPos.y);
			break;
		default:
			break;
		}    
}
{% endhighlight %}

3番の線を書く足場はワールドアップデート外でないと描けない為、↑のプログラムから除外されます

{% highlight cpp %}
//線を描く足場
if (!play && inputMode == 2)
{
	if (MouseL.pressed())
	{
        // 書き込む線の始点は直前のフレームのマウスカーソル座標
        // （初回はタッチ操作時の座標のジャンプを防ぐため、現在のマウスカーソル座標にする）
        const Point from = MouseL.down() ? Cursor::Pos() : Cursor::PreviousPos();
        // 書き込む線の終点は現在のマウスカーソル座標
		const Point to = Cursor::Pos();
		// image に線を書き込む
		Line(from, to).overwrite(image, thickness, Palette::Gray);
            // 書き込み終わった image でテクスチャを更新
            texture.fill(image);
		}
		else if (MouseL.up())
		{
// 画像の非透過部分から Polygon を作成（穴無し）
if (const Polygon polygon = image.alphaToPolygon(1, false))
{
	// Polygon を適切な位置に移動し、P2Body として追加
	const Polygon polygon2 = polygon.simplified(2.0)
		.moveBy((-canvasSize / 2).x + 10, (-canvasSize / 2).y).scale(1 / camera.getScale());
	floors << world.createStaticPolygon(camera.getCenter(), polygon2);
}
// 画像データをリセット
image.fill(Color(0, 0));
// テクスチャを更新
texture.fill(image);
		}

}
{% endhighlight %}

↑のメニューをコントロールするGUI

{% highlight cpp %}
#pragma region GUI

SimpleGUI::RadioButtons(inputMode, { U"Floor", U"Goal",U"Pen Floor", U"Delete",U"Start Pos" }, Vec2(395, 10), 180, !play);
SimpleGUI::Slider(U"Size:{:.1f}"_fmt(size), size, 1.0, 10.0, Vec2(395, 230), 80, 120, !play);
SimpleGUI::Slider(U"Rot:{:.1f}"_fmt(rot), rot, 0.0_deg, 180.0_deg, Vec2(395, 280), 80, 120, !play);
if (SimpleGUI::Button(U"Play", Vec2(395, 500)))
{
	if (play) {

		myBall.setVelocity(Vec2(0, 1));
		clicking = false;
		canJump = false;
		play = false;
		aiming = false;
	}
	else
	{
		ClearPrint();
		inputMode = -1;
		myBall.setPos(spwanPos);
		myBall.setVelocity(Vec2(0, 1));
		clicking = false;
		canJump = false;
		jumpNum = 0;
		aiming = false;
		play = true;
	}
}
if (SimpleGUI::Slider(volume, Vec2(395, 550)))
for (const auto& audio : audioList) {
	// 音量を設定 (0.0 - 1.0)
	audio.setVolume(volume);
}

texture.draw();
font(U"Jump: {} times\n"_fmt(jumpNum)).draw(12, 20, ColorF(0.25));
font2(U"音楽：魔王魂\nMusic from https://www.zapsplat.com").draw(395, 470, ColorF(0.25));

// 単純化した Polygon の頂点数を表示
ClearPrint();
#pragma endregion
{% endhighlight %}

すべての描画のプログラム、プレイ時にジャンプ方向に応じて回転する指の絵文字の処理もこちら

{% highlight cpp %}
#pragma region 描画
//出す足場テスト
testingLine.draw(Palette::Black);
P2Body ViewBall = world.createKinematicCircle(spwanPos, 1);
//描画
// 枠を描画
for (const auto& frame : frames)
{
    frame.draw(Palette::Black);
}
//足場を描画
for (const auto& f : floors)
{
    if (!floorCollidedIDs.includes(f.id())) {
	   floorCollidedIDs << f.id();
}
    f.draw(Palette::Black);
}
//ゴールを描画
for (const auto& g : Goal)
{
    g.draw(Palette::Red);
}

if (play) {
    myBall.draw(Palette::Black);
}
else
{
    ViewBall.draw(Palette::Orange);
}
if (aiming) {
    double ang = Math::Atan2(Cursor::Pos().y - enterPos.y, Cursor::Pos().x - enterPos.x);
    double dis = twoPointDistance(enterPos, Cursor::Pos());
if (dis > 40) { dis = 40; }
    dis /= 2;
//最小と最大の力を制限
if (dis < 5) { dis = 5; }
    arrow.resized(5, dis).rotated(-90_deg + ang).drawAt(myBall.getPos());
}
#pragma endregion
{% endhighlight %}